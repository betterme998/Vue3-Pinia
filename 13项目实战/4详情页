1.导航栏搭建，使用vant
  .修改主题颜色
2.轮播图
  2.1.请求数据
    数据有点复杂就先看要做那个模块，找到模块的数据从复杂数据中抽离出去，抽离出去就可以把每个部分封装成组件。把抽离
    的数据传递给组件，让组件帮助展示。
    1.在service的modules中创建detail.js 来写发送网络请求的函数
    2.在详情页的store中调用数据请求函数
    3.在详情页调用store中封装的方法并传入参数
  2.2.由于数据复杂,一个一个拿比较复杂,所以可以使用computed去拿到指定的值,用起来会相对方便一些

  2.3.使用vant封装轮播图,单独抽成组件,放到cpns文件夹中

3.自定义轮播图指示器
  当图片越来越多的时候就会有很多指示器，官方就对其进行分类，但是请求的数据没有分类，要自己分类。
  3.1.使用vant轮播图中自定义指示器，通过作用域插槽拿到子组件传过来的值，并使用

  3.2.对数据进行分类
    .数据是通过一个值来区别是哪里的数据如：1,2，3,4等.将原有数据处理成对象，对应是由key-value组成的，使用用来区分的数子作为key，使用数组来存放所以对应key的数据作为value。
      .分好类就可以遍历，就可以决定轮播图的类别
      {
        "2":[item1,item2,...],
        "4":[itemx,itemy,...],
        "8":[itema,itemb,...]
      }
    1.对数据进行转换
    2.对数据进行展示
    3.使用正则表达式处理自定义标签的title
    4.选中状态
      .样式改变
  
    轮播图自定义标签总结：
      从store中拿到数据后,对数据进行重构。数组重构成对象形式。
      展示部分数据，并使用正则表达式处理title，三元运算符绑定action class
      使用插件解决刷新store数据消失问题
      并使用监听器监听从store获取的数据，如变化重新执行数据处理逻辑
      通过拿到当前展示图片的item数据（使用从store中的数据拿），传递给标签数据处理函数。拿到对应key对应的组件。通过fineIndex判断是否有，并返回，拿到当前轮播的index

4.店铺信息
  1.新创建一个组件写店铺信息
  2.拿到数据进行展示

5.房屋措施
  1.因为结构和后面的差不多，封装一个组件，因为比较通用放到compoents中detail-section
  2.在创建一个组件使用上面的组件封装一个房屋设施的组件

6.房东介绍
7.评论

8.地图
  1.地图如何嵌入前端项目
    .申请称为百度地图开发者
    .登录后点击 控制台 注册称为开发者
    .针对应用程序创建AppKey
      控制台->应用管理->我的应用->创建应用
    .在jsvascript API中查看使用方法
      .将其中<script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&&type=webgl&ak=您的密钥">
      </script>导入到项目中
      .导入到最外层的index.html中
    .这样就能在项目中使用百度地图API了
  
  2.拿到经纬度数据,并使用
  3.地图加上大头针遮盖层

9.详情页滚动到某个位置出现导航栏，点击对应的选项滚动到当前位置
  1.先开发出tabbat
  2.监听滚动
    .滚动到一定位置时显示出来
  3.监听tabbar中的点击，点击之后滚动到正确的位置

  4.通过绑定ref，点击后通过 绑定的ref.value.scrollTo滚动到想要的位置

  5.动态的绑定ref
    1.给页面中需要定位的组件ref绑定函数，该函数的参数就是当前组件的ref。所有的都绑定一个相同的函数
    2.给所有绑定函数的ref组件添加一个name属性
    3.详情页面tab的数据来源于2中的name
      .把参数push到数组中
      .需要在绑定的父元素上加上v-more 来指定响应对象，不然滚动会一直执行绑定的函数.
    .拿到所有ref的$el的数组，再通过点击传过来的index拿到组件对应的top

9.tab导航-总结
  1.封装组件，传入title。点击发送自定义事件，传出index
  2.滚动到一定位置显示tab，通过封装的hooks方法.
      .细节：滚动的hooks方法可以接受参数，为ref（一个元素）
      .滚动分为window滚动，和元素滚动。元素滚动是元素设置height:100vh;overflow-y：auto;
      .返回-> 是否达到底部,滚动的位置,可以滚动的高度,理想屏幕高度
  3.点击标题，滚动到指定位置
      原理：1.通过给需要点击滚动到该位置的组件，绑定ref ，为函数。
            2.添加name属性，作用是为和tab关联起来。当做tab的title 

            3.定义一个响应式的对象，该对象key为绑定ref组件的name属性值，值为组件的跟元素.
            4.有了第三步，定义一个计算属性 拿到该响应对象所有的key 通过Object.Keys 

            5.绑定给组件的ref 函数有返参数 ref本身。 通过ref获取对应组件的name 通过getAttribute获取
              吧name传入到tab
              在用name作为第三步的key，ref本身作为值，这样就保存下来了数据
            
            6.点击具体标签时监听自定义事件，并接受参index
            1.拿到key 
              通过Object.keys() 拿到第三步响应对象的key组件，在根据index拿到具体key
            2.拿到元素
              因为拿到key，直接通过第三步的响应对应拿到元素

            3.拿到元素的offsetTop高度
            4.通过滚动的元素的scrollTo()方法实现滚动

回顾
一.Loading展示
  1.loading组件搭建
  2.loading状态保存
    .mainStore
  3.loading改变状态
    .hyRequest中的拦截器中

二.详情页 
  1.点击item跳转
  2.详情页导航搭建
  3.详情页数据请求和管理
  4.详情页轮播图的搭建
    .轮播图 
    .自定义指示器 
  5.描述信息的搭建
  6.detail-section组件
  7.搭建内容部分
    .设施
    .房东
    .评论
    .须知
  8.引入百度地图
  9.tabControl控制
    1.使用之前封装的组件
    2.控制tabControl的显示
      监听元素滚动 》300显示
    3.tabControl的点击
      .获取组件根元素offsetTop，ref绑定函数的方式
      .监听点击找到元素，滚动到对应的位置
      .动态属性name，把这个name放到绑定ref元素上


比较复杂的两个部分：轮播图自定义标签
                  tab


作业
一。理解页面滚动和元素之间的区别和实现

二.页面跳转时，如何保持原有页面的滚动位置

12.滚动详情页到具体位置，tab选中状态也改变
  1.页面滚动到一定位置时，显示正确的tabControl的索引(标题)
    1.监听滚动的位置 scrollTop

    2.利用scrollTop去匹配正确位置
      offsetTop
      [描述300，设施500，房东800，评论1200，须知1400，周边1700]
      [300,500,800,1200,1400,1700]
      当滚动的位置为600时，在500-800之间，我们显示设施
      问题：怎么样才能得到滚动的位置所在的区间呢？
      使用算法
        遍历数组，找到大于scrollTop的值，但是我们要展示的是他前一个值。
        const values = [300,500,800,1200,1400,1700]
        //index 不能随便写，因为需要匹配到前一个值。当匹配不到时为默认最后一个。因为我们要匹配到最后一个，必须满足value>scrollTop，但最后一个没有后面的值，
        //所以匹配不到默认 index默认为最后的index
        let index = values.length-1
        for(let i = 0；i<values.length；i++){
          const value = values[i]
          if(value > scrollTop) {
            index = i - 1
            break
          }
        }
13.每一个程序都会经过 vite/webpack  里面有postcss工具，我们往里面添加插件 ->plugins ->postcss-px-to-viewport



