# 目录
  1.认识CompositionAPI
    Options API的弊端
      .在Vue2中，我们编写组件的方式是Options API ：
        .Options API的一大特点就是在对应的属性中编写对应的功能模块；
        .比如data定义数据，methods中定义方法，computed中定义计算属性，watch中监听属性改变，也包括生命周期钩子
      .但是这种代码有一个很大的弊端
        .当我们实现一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；
        .当我们组件变得更大更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很散；
        .尤其是对于那些一开始没有编写这些组件的人来说，这个组件代码是难以阅读和理解的（阅读组件是其他人）
      大组件的逻辑分散
        .如果我们能将同一个逻辑关注点的代码收集在一起会更好
        .这就是CompositionAPI想要做的事情，以及可以帮助我们完成的事情。
        .也有人把Vue CompositionAPI简称为VCA

    认识CompositionAPI
      那么既然知道Composition API想要帮助我们做什么事情，接下来看一下到底是怎么做呢？
        .为了开始使用Composition API，我们需要有一个可以实际使用它（编写代码），的地方；
        .在Vue组件中，这个位置就是setup函数
    
      setup其实就是组件的另外一个选项：
        .只不过这个选项强大到我们可以用它来代替之前编写所编写
        .比如methods，computed，watch，data，生命周期等等；

      接下来学习使用这个函数
        .函数的参数
        .函数的返回值

        1.setup函数的参数
          我们先来研究一个setup函数的参数，它主要有两个参数：
            第一个参数：props
            第二个参数：context
          props非常好理解，它其实就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：
            .对于定义props的类型，我们还是和之前的规则是一样的，在Props选项中定义；
            .并且在template中依然是可以正常去使用props中的属性，比如message；
            .如果我们在setup函数中想要使用props，不可以通过this去获取（后面会讲）
            .因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；
          另一个参数context，我们也称之为是一个SetupContext，它里面包含三个属性：
            1.attrs:使有的非prop的attribute
            2.slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；
            3.emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过this.$emit发出事件）；

        2.setup函数的返回值
          setup既然是一个函数，那么它也可以有返回值，它的返回值用来做什么呢？
            .setup的返回值可以在模板template中被使用；
            .也就是说我们可以通过setup的返回值来替代data选项；
          甚至是我们可以返回一个执行函数来代替在methods中定义的方法
        
        3.Reactive API
          在02_setup定义数据中有使用
          如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数

          那么这是什么原因呢？为什么就变成响应式的呢？
            这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；
            当数据发生改变时，所有收集的依赖都是进行对应的响应式操作（比如界面更新）
              解释：
                这和data(){return{}} 返回的对象一样，会被tempalte劫持。当template使用这个数据时就会监听数据的改变，当data数据改变，template
              也会改变
                .reactive函数也是一样的，通过reactive定义的数据才会被template劫持，被劫持后去修改它，template才会有响应的

              事实上，我们编写的data选项，也是在内部交给reactive函数将其编程响应式对象；
        
        4.Ref API
          reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型；
            .如果我们传入一个基本类型（String，Number，Boolean）会报一个警告；
          
          这个时候vue3给我们提供了另一个API： ref API
            .ref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是ref名称的来源
            .它内部的值是在ref的value属性中被维护的

          注意事项：
            1.在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过ref.value的方式来使用
            
        5.// 3.ref是浅层解包
          // Ref自动解包（测试已经修改）
          // 模板中的解包是浅层的解包，如果我们的代码是下面的方式；
          // 当值放到对象中时template就要使用.value  vue3.1时，但已经改了
          // 不过，如果ref值放到对象中，然后修改值时要加上.value。才能修改

    第一部分总结：
      一.Composition API
        1.1.options API -> Composition API
        1.2.组合API实现计数器案例
        
      作业：
        1.如何进行非父子组件的通信

        2.什么是生命周期函数？说说你对它回调的理解

        3.说说你对动态组件和keep-alive的作用理解

        4.对组件使用v-model的本质是什么？

        5.什么是Composition API？ 和之前的options API有什么区别


      

  2.Setup函数的基本使用

  3.Setup中数据的响应式

  4.Reactive知识点补充
    1.认识readonly （只读）
      我们通过reactive或者ref可以获取到一个响应式的对象，但是在某些情况下，我们传入给其他地方（组件）的这个响应式对象希望另外一个地方（组件）
      被使用，但是不能被修改，这个时候如何防止这种情况出现呢？

        .vue3为我们提供了readonly的方法
        .readonly会返回原生对象的只读代理（也就是它依然是一个proxy，这是一个proxy，这是一个proxy的set方法被劫持，并且不能对其进行修改）
      
      在开发中常见的readonly方法会传入三个类型的参数
        类型一：普通对象
        类型二：reactive返回的对象
        类型三：ref对象
      
      在readonly的使用过程中，有如下规则
        readonly返回的对象都是不允许修改的；
        但是经过readonly处理的原来的对象是允许被修改的
          .比如const info = readonly(obj),info对象是不允许被修改的；
          .当obj被修改时，readonly返回的对象也会被修改；
          .但是我们不能去修改readonly返回的对象info
        
        其实本质上就是readonly返回的对象的setter方法被劫持了而已
    
    2.Reactive判断的API
      1.isProxy
        检查对象是否由reactive或readonly创建的proxy
      2.isReactive
        检查对象是否是由reactive创建的响应式代理
        如果该代理是readonly创建的，但包裹了由reactive创建的另一个代理，它也会返回true
      3.isReadonly
        检查对象是否由readonly创建的只读代理
      4.toRaw
        返回reactive或readonly代理的原始对象（不建议保留对原始的持久引用，请慎重使用）

      5.shallowReactive   （就是默认reactive会监听深层的变化，使用shallowReactive只监听浅层的变化，嵌套的对象里面的属性发生改变就不会监听到）
        创建一个响应式代理，它跟踪其自身property的响应性，但不执行嵌套对象的深层响应式转换（深层还是原生对象）


  5.Ref知识点补充
    04_setup中toRefs
    1.toRefs
      .如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive返回的state对象，数据都
      不再是响应式的：

      .那么有没有办法让我们解构出来的属性是响应式的呢？
        Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref
    2.toRef
      .如果我们只希望转换一个reactive对象中的属性为ref。那么可以使用toRef方法

    3.ref其他的API
      1.unref
        如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：
          .如果参数是一个ref，则返回内部值，否则返回参数本身
          .这是val - isRef（val） ？ val.value : val 的语法糖
      2.isRef 
        判断是否是一个ref
      
      3.shallowRef
        创建一个浅层的ref对象  (当我们修改嵌套的值的属性时，不会触发响应式)

      4.triggerRef
        手动触发和shallowRef相关联的副作用  （接上一个：如果想触发需要手动执行这个函数）
      
      3和4例子：
        const info = shallowRef({name: "why"}); 创建了一个浅层的ref对象

        ; 下面的修改不是响应式的
        const changinfo = () => {
          info.value.name = "betterme"

          ; 手动触发 后才会是响应式的
          triggerRef(info)
        }

  6.setup中禁用this
    1.setup不可以使用this
      官方关于this有这样一段描述（）
        .表达的含义是this并没有指向当前数组实例
        .并且在setup调用之前，data，computed，methods等都没有被解析；
        .所以无法在setup中获取this

  7.computed函数使用
  05_Setup中computed
    .在我们前面讲解过计算属性computed：当我们的某些属性是依赖其他状态时，我们可以使用计算属性来处理
      .在前面的Options API中，我们是使用computed选项来完成的
      .在Composition API中，我们可以在setup函数中使用computed方法来编写一个计算属性
    
    .如何使用computed呢？
      .方式一：接收一个getter函数，并为getter函数返回的值，返回一个不变的ref对象
      .方式二：接收一个具有get和set的对象，返回一个可变（可读写）的ref对象
  
    setup中使用ref
      .在setup中如何使用ref获取元素或者组件？
        .其实非常简单，我们只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可

  8.组件的生命周期函数
    1.生命周期钩子 
      我们前面说过setup可以用来替代data，methods，computed 等等这些选项，也可以代替生命周期钩子

      那么setup中如何使用生命周期函数呢？
        可以使用直接导入的onX函数注册生命周期钩子
      
      <!-- 
      选项式API （vue2）    Hook inside  setup (钩子 内部 设置)vue3
      beforeCreate         Not needed (不在需要)
      created              Not needed
      beforeMounte         onBeforMounte
      mounted              onMounted
      beforeUpdate         onBeforUpdate
      updated              onUpdated
      beforUnmount         onBeforUnmount
      unmounted            onUnmounted
      activated            onActivated
      deactivated          onDeactivated
     -->
     <!--beforeCreate和 created不在需要
      因为setup是围绕beforeCreate和 created生命周期钩子运行的，所以不需要显示的定义他们，换句话说，在这两个钩子中编写
      的代码都应该直接在setup函数中编写

  9.Provide/Inject使用  provide（提供） Inject（投入，注射）
    1.Provide函数
      事实上我们之前还学习过provide和inject，Composition API也可以代替之前的Provide 和 Inject的选项。
      我们可以通过provide来提供数据
        可以通过provide方法来定义每个Property
      .provide可以传入两个参数：
        name：提供的属性名称；
        value：提供的属性值
    2.Inject函数
      在后代组件中可以通过inject来注入需要的属性和对应的值
        可以通过inject来注入需要的内容；
      inject可以传入两个参数：
        要inject得property的name
        默认值
    3.数据的响应式
      为了增加provide值和inject直接的响应性，我们可以在provide值使用ref和reactive
      


  10.watch/watchEffect
    1.侦听数据变化
      侦听数据变化
      在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些操作
      在Composition API中，我们可以使用watchEffect和wach来完成响应式数据的侦听；
        watchEffect:用于自动收集响应式数据的依赖
        watch：需要手动指定侦听的数据源；

      1.Watch的使用
        watch的API完全等同于组件watch选项的Property
          .watch需要侦听特定的数据源，并且执行其回调函数；
          .默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调
        侦听多个数据源
          侦听器还可以使用数组同时侦听多个源
        watch的选项
          .如果我们希望侦听一个深层的侦听，那么依然需要设置deep为true：
            也可以传入immediate立即执行
      2.watchEffect
        .当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候就可以使用watchEffect
        
        watchEffect的停止侦听
          如果发送某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可

  11.自定义Hook练习
    10_Setup-Hooks练习

    

  12.script setup语法糖