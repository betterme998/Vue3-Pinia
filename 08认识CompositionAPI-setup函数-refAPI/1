# 目录
  1.认识CompositionAPI
    Options API的弊端
      .在Vue2中，我们编写组件的方式是Options API ：
        .Options API的一大特点就是在对应的属性中编写对应的功能模块；
        .比如data定义数据，methods中定义方法，computed中定义计算属性，watch中监听属性改变，也包括生命周期钩子
      .但是这种代码有一个很大的弊端
        .当我们实现一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；
        .当我们组件变得更大更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很散；
        .尤其是对于那些一开始没有编写这些组件的人来说，这个组件代码是难以阅读和理解的（阅读组件是其他人）
      大组件的逻辑分散
        .如果我们能将同一个逻辑关注点的代码收集在一起会更好
        .这就是CompositionAPI想要做的事情，以及可以帮助我们完成的事情。
        .也有人把Vue CompositionAPI简称为VCA

    认识CompositionAPI
      那么既然知道Composition API想要帮助我们做什么事情，接下来看一下到底是怎么做呢？
        .为了开始使用Composition API，我们需要有一个可以实际使用它（编写代码），的地方；
        .在Vue组件中，这个位置就是setup函数
    
      setup其实就是组件的另外一个选项：
        .只不过这个选项强大到我们可以用它来代替之前编写所编写
        .比如methods，computed，watch，data，生命周期等等；

      接下来学习使用这个函数
        .函数的参数
        .函数的返回值

        1.setup函数的参数
          我们先来研究一个setup函数的参数，它主要有两个参数：
            第一个参数：props
            第二个参数：context
          props非常好理解，它其实就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：
            .对于定义props的类型，我们还是和之前的规则是一样的，在Props选项中定义；
            .并且在template中依然是可以正常去使用props中的属性，比如message；
            .如果我们在setup函数中想要使用props，不可以通过this去获取（后面会讲）
            .因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；
          另一个参数context，我们也称之为是一个SetupContext，它里面包含三个属性：
            1.attrs:使有的非prop的attribute
            2.slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；
            3.emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过this.$emit发出事件）；

        2.setup函数的返回值
          setup既然是一个函数，那么它也可以有返回值，它的返回值用来做什么呢？
            .setup的返回值可以在模板template中被使用；
            .也就是说我们可以通过setup的返回值来替代data选项；
          甚至是我们可以返回一个执行函数来代替在methods中定义的方法
        
        3.Reactive API
          在02_setup定义数据中有使用
          如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数

          那么这是什么原因呢？为什么就变成响应式的呢？
            这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；
            当数据发生改变时，所有收集的依赖都是进行对应的响应式操作（比如界面更新）
              解释：
                这和data(){return{}} 返回的对象一样，会被tempalte劫持。当template使用这个数据时就会监听数据的改变，当data数据改变，template
              也会改变
                .reactive函数也是一样的，通过reactive定义的数据才会被template劫持，被劫持后去修改它，template才会有响应的

              事实上，我们编写的data选项，也是在内部交给reactive函数将其编程响应式对象；
        
        4.Ref API
          reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型；
            .如果我们传入一个基本类型（String，Number，Boolean）会报一个警告；
          
          这个时候vue3给我们提供了另一个API： ref API
            .ref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是ref名称的来源
            .它内部的值是在ref的value属性中被维护的

          注意事项：
            1.在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过ref.value的方式来使用
            
        5.// 3.ref是浅层解包
          // Ref自动解包（测试已经修改）
          // 模板中的解包是浅层的解包，如果我们的代码是下面的方式；
          // 当值放到对象中时template就要使用.value  vue3.1时，但已经改了
          // 不过，如果ref值放到对象中，然后修改值时要加上.value。才能修改

    第一部分总结：
      一.Composition API
        1.1.options API -> Composition API
        1.2.组合API实现计数器案例
        
      作业：
        1.如何进行非父子组件的通信

        2.什么是生命周期函数？说说你对它回调的理解

        3.说说你对动态组件和keep-alive的作用理解

        4.对组件使用v-model的本质是什么？

        5.什么是Composition API？ 和之前的options API有什么区别


      

  2.Setup函数的基本使用

  3.Setup中数据的响应式

  4.Reactive知识点补充
    1.认识readonly （只读）
      我们通过reactive或者ref可以获取到一个响应式的对象，但是在某些情况下，我们传入给其他地方（组件）的这个响应式对象希望另外一个地方（组件）
      被使用，但是不能被修改，这个时候如何防止这种情况出现呢？

        .vue3为我们提供了readonly的方法
        .readonly会返回原生对象的只读代理（也就是它依然是一个proxy，这是一个proxy，这是一个proxy的set方法被劫持，并且不能对其进行修改）
      
      在开发中常见的readonly方法会传入三个类型的参数
        类型一：普通对象
        类型二：reactive返回的对象
        类型三：ref对象
      
      在readonly的使用过程中，有如下规则
        readonly返回的对象都是不允许修改的；
        但是经过readonly处理的原来的对象是允许被修改的
          .比如const info = readonly(obj),info对象是不允许被修改的；
          .当obj被修改时，readonly返回的对象也会被修改；
          .但是我们不能去修改readonly返回的对象info
        
        其实本质上就是readonly返回的对象的setter方法被劫持了而已
    
    2.Reactive判断的API
      1.isProxy
        检查对象是否由reactive或readonly创建的proxy
      2.isReactive
        检查对象是否是由reactive创建的响应式代理
        如果该代理是readonly创建的，但包裹了由reactive创建的另一个代理，它也会返回true
      3.isReadonly
        检查对象是否由readonly创建的只读代理
      4.toRaw
        返回reactive或readonly代理的原始对象（不建议保留对原始的持久引用，请慎重使用）

      5.shallowReactive   （就是默认reactive会监听深层的变化，使用shallowReactive只监听浅层的变化，嵌套的对象里面的属性发生改变就不会监听到）
        创建一个响应式代理，它跟踪其自身property的响应性，但不执行嵌套对象的深层响应式转换（深层还是原生对象）


  5.Ref知识点补充

  6.setup中禁用this
