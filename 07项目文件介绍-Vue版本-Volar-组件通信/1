# 1.jsconfig.js的演示
  在02_product_demo文件当中修改webpack路径配置后不会有提示，需要修改jsconfig.js具体在02_product_demo/utils/index

# 2.引入的vue的版本
  主要解释在main 和 App.vue文件
  默认vue版本（就是import { createApp } from 'vue'）：runtime， vue-loader完成template的编译过程 （仅限于.vue文件）
  另一个版本：（import { createApp } from "vue/dist/vue.esm-bundler.js"）：runtime + compile，对template进行编译 （就是源码）

  webpack打包入口文件-》main.js在main.js里面会有一个createApp（App）需要根组件，所以要开发根组件-》创建App.vue组件，然后
  根组件里面也可以用组件，每个组件都有自己的逻辑，样式
#  3.补充：单文件Vue style是有自己的作用域
  给style加上 scoped

#  4.补充：vite创建一个Vue项目
  创建项目方式：Vue Cli：vue create  （基于webpack创建的）  （02_product_demo）
               npm init vue@latest：  （基于vite创建的）
                1.安装一个本地工具：create vue
                2.使用create-vue创建一个vue项目

#  02_product_demo项目utils文件夹，main.js等注意内容

# 5.组件通信 
  04_learn_Component
  最终开发出来的东西最终会形成一个组件树，很多情况需要a组件传递一些数据到b组件，b组件发生的事件需要传递到a组件（这就涉及到组件通信）
  1.Vue组件的嵌套关系
    .前面我们是将所有的逻辑放到一个App.vue中：
    .如果我们一个应用程序将所有逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护
    .所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件
    .再将这些组件嵌套在一起，最终形成我们的应用程序；

    当我们对组件进行拆分之后，这时数据还在根组件我们需要将数据传入其他组件

  2.父组件传递子组件
    在开发过程中，我们会经常遇到需要组件之间相互通信；
      可能是子组件发生了事件，需要父组件来完成某些操作，那就需要子组件向父组件传递事件
      要么就是父组件传递数据给子组件等等。。。。

    2.1父子组件之间通信的方式
      1.父组件传递子组件：通过props属性
      2.子组件传递父组件：通过$emit触发事件
    
    2.2在开发中常见的父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：
      这个时候我们可以通过props来完成组件之间的通信

    2.3什么是Props呢？
      .Props是你可以在组件上注册一些自定义的attrbute
      .父组件给这些attribute赋值，子组件听过attribute的名称获取到对应的值
      attribute：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute； 
    2.4.Props的数组用法
          存在一个弊端：1.不能对类型进行验证,2.没有默认值
      .Props的对象用法
          使用对象语法可对传入的内容进行限制
          1.类型
          2.是否必传
          3.默认值
          
          细节一：type的类型都可以是那些
            String
            Number
            Boolean
            Array
            Object
            Date
            Function
            Symbol
          细节二：对象类型的其他写法
            当默认值是一个对象是，必须吧default写成一个函数
            数组类型 default也得写成函数

          细节三：prop的大小写命名
            .html中attribute名是大小写不敏感的，会把大写变小写
            .这意味着使用DOM模板时，（驼峰命名法）的prop名需要使用等价的bebab-case（短横线分隔符命名法）

  3.非props的attribute （ attribute：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute； ）
    .当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就被称之为非Prop的Attribute；
    .常见的包括class,style,id等属性；
  .attribute继承
      当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中 
  
  如果不希望组件根元素继承attribute，可以在组件中设置inheritAttrs:false
    .禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素
    .我们可以通过$attrs来访问所有的非props的attribute


  4.子组件传递父组件
    一般情况下子组件传递给父组件，都是因为在子组件触发了事件，父组件需要做出响应
    什么情况需要传递内容到父组件？
    .当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容
    .子组件有一些内容想要传递给父组件的时候

    我们如果完成上面的操作呢？
      1.首先，我们需要子组件中定义好在某些情况下触发的事件名称；
      2.其次，在父组件中以v-on的方式传入要监听的事件名称，并绑定到对应的方法中；
      3.最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件

  5.自定义事件的参数和验证(了解)
    vue3通过emits对参数进行验证。在03_组件通信-子传父 AddCounter.vue中

  6.组件通信案例练习

  # Vue 组件化-插槽Slot/非父子通信
  04_learn_Component/05组件插槽-
  1.认识插槽Slot作用
    1.1.在开发中，我们会经常封装一个个不可复用的组件
      .前面我们会通过props传递给组件一些数据，让组件来进行展示
      .但是为了让这个组件具备更强的通用性，我们不能将组件的内容限定为固定的div，span等等这些元素
      .比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示一种图片
      .我们应该让使用者可以决定某一块区域到底存放什么内容和元素
    1.2举例：假如我能定制一个通用的导航组件-NavBar
      .这个组件分三个区域：左边-中间-右边，每块区域内容都不是固定的；
      .左边区域可能是菜单图标，也可能是返回按钮，其他同理
      这就可以使用插槽

  2.插槽Slot基本使用
    定义插槽
      1.插槽的使用过程其实就是抽取共性。预留不同
      2.我们会将共同的元素，内容依然在组件内进行封装；
      3.同时会将不同的元素使用slot作为占位符，让外部决定到底显示什么样的元素
    
    如何使用插槽slot
      1.Vue中将<slot>元素作为承载分发内容的出口
      2.在封装组件中，使用特殊的元素<slot>就可以封装组件开启一个插槽
      3.该插槽插入什么取决于父组件如何使用；

    插槽的默认内容
      有时候我们希望在使用插槽时，如果没有插入对应的内容，那么我们需要显示一个默认的内容
      .当然这个默认的内容只会在没有提供插入的内容时，才会显示

  3.具名插槽Slot使用
    事实上，我们希望达到的效果是插槽对应的显示，这个时候我们就可以使用 具名插槽
      .具名插槽顾名思义就是给插槽起一个名字，<slot>元素有一个特殊的attribute：name
      .一个不带name的slot，会带有隐含的名字default

    动态插槽名
    06具名插槽app.vue中有
    什么是动态插槽
      .目前我们使用的插槽名称都是固定的；
      .比如v-slot:left。等
      .我们可以通过v-slot:[dynamicSlotName]方式动态绑定一个名称；

    具名插槽使用的时候缩写
      .跟v-on和v-bind一样，v-slot也有缩写；
      .即把参数之前的所有内容（v-slot:）替换为字符#；

    渲染作用域
    在Vue中有渲染作用域的概念
      .父级模板里的所有内容都是在父级作用域中编译的
      .子模板里面的所有内容都是在子作用域中编译的
    
    独占默认插槽的缩写
      如果我们的插槽默认插槽default，那么在使用的时候v-slot:default="slotProps" 可以简写为v-slot="slotProps"

      如果我们的插槽只是默认插槽时，组件的标签可以被当做插槽的模板来使用，这样我们就可以将v-slot直接用在组件↑

    默认插槽和具名插槽混合
      但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写
      只要出现多个插槽，请始终为所有的插槽使用完整的基于<template>的语法

  回顾：
    一。补充
      1.1jsconfig的作用

      1.2vue不同版本的作用
      .runtime 运行时
      .runtime+comiple 运行时+编译

      1.3css的scoped作用域

      1.4你配吗init vue@/latest创建项目
      .vite打包

    二、组件间的通信
    2.1.组件的嵌套关系
      .父组件/子组件
    2.2.父传子 
    2.3非props的attribute
    2.4子传父-$emit (重要)
    2.5.阶段案例练习-TabControl的封装

    三.组件的插槽Slot
    3.1.认识slot的作用
    3.2slot的基本使用和默认值(重要)
    3.3slot的具名插槽(重要)
    3.4动态插槽名
    3.5编译作用域
    3.6作用域插槽使用 
      .核心：将子组件的数据传递给父组件的插槽来使用


  4.非父子组件通信
    在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信
    这里我们主要将两种方式：
      .全局事件总线：
      .Provide/Inject



  5.全局事件总线使用
    1.全局事件总线mitt库
    Vue3实例中移除了$on,$off,$once方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库；
      vue3官网有推荐一些库，例如mitt 或者 tiny-emitter
      这里我们主要讲hy-event-store
      

  6.依赖注册Provide/Inject
    # Provide/Inject用于非父子组件之间共享数据
  .比如有一些深度嵌套的组件好几层，子组件想要获取父组件的部分内容；
  .在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；\

  .对于这种情况，我们可以使用Provide （翻译：提供）和Inject （翻译：添加）
    无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者
    父组件有一个provide选项来提供数据
    子组件有一个inject选项来开始使用这些数据

  .实际上，可以将依赖注入看作是“long range props” （远程工具），除了；
    父组件不需要知道哪些些子组件使用它provide的property （属性）
    子组件不需要知道inject的property来自哪里

  provide当中不会把数据写死，先获取数据，然后存到data当中，再把数据给provide。如何实现？
   1.provide和inject函数的写法
    如果Provide中提供的一些数据来自data，那么我们可能会想通过this来获取
    但是这里this的指向在window，所以provide要写成函数

  2.处理响应式数据
    我们修改数据之后，之前在provide中引入的this.names.length本身并不是响应式的
    那么怎么样让数据变成响应式的呢？
      .使用响应式API来完成，比如computed
    注意：在子组件使用传过来的数据时需要取其中的value
      因为使用的computed返回的是一个ref对象，需要取出其中的value使用

#7.组件化-额外知识补充
  1.组件的生命周期 (必须掌握)
    1.1.认识生命周期
      什么是生命周期呢？
        .生物学上，生物生命周期指的是一个生命体在生命开始到结束周而复始所经历的一系列变化过程
        .每个组件都可能会经历创建，挂载，更新，卸载等一系列的过程；
        .在这个过程中的某一个阶段，我们可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）；
        .但是我们如何知道目前组件正在哪一个过程呢？Vue给我们提供了生命周期函数

      生命周期函数：
        .生命周期函数是一些钩子函数（回调函数）,在某个时间会被Vue源码内部进行回调；
        .通过对生命周期的回调，我们可以知道目前组件正在经历什么阶段
        .那么我们就可以在该生命周期中编写属于自己的逻辑代码了；

      生命周期的流程
        当创建vue实例并挂载app = Vue.createApp(option) app.mount(el) 当完成初始化操作之后，会回调生命周期 beforCreate （组件还没有被创建出来回调的函数）
        回调完beforCreate后 会创建组件实例，创建后回调created 生命周期，（表示组件已经被创建完啦，但是没有挂载到app的tempplate中），当完成created后，会
        进行判断，判断是否有template，因为组件实例被创建,组件本身又有render函数返回template，这些template也需要被解析，当模板准备被编译的时候，会看template选项 如果有template
        会将template变成渲染函数，渲染函数就会返回vnode，如果没有template就会编译el的innerHTML至模板。
          有模板之后就可以挂载到组件app上面，在挂载之前会先进行beforeMount （就是还没有挂载时执行的生命周期函数），当挂载
        好了之后会执行mounted （挂载完毕执行的生命周期函数），挂载好后就已经在虚拟dom上面，之后根据算法将虚拟dom渲染成真实dom
        生成了真实dom后，改变数据时，会在改变之前调用beforeUpdate（数据改变之前调用的生命周期），数据发送改变就会根据数据生成
        新的vnode，虚拟dom发送改变就会触发diff算法渲染成真实dom。更新完真实dom会触发updated（数据更新完成后触发的生命周期）
          当组件不需要时会被销毁掉，销毁之前会触发beforeUnmount生命周期（组件销毁前执行的生命周期），当虚拟dom被销毁后又会
        触发unmount生命周期函数（组件销毁后执行的生命周期），然后销毁实例。

        总结：
        当某个地方用到了组件，不管是根组件还是其他组件：
        beforCreate  ;//在创建之前调用
        1.   //会先创建组件实例->instance (js对象) 
        create ;创建完成回调 （重要 1.发送网络请求 2.事件监听）
        2.template模板编译
        beforMount
        3.挂载到虚拟DOM
        虚拟DOM->真是DOM->界面看到
        mounted （重要 元素已经被挂载，再mounted获取dom，使用dom）
        4.数据更新 
        beforeUpdate
        根据最新数据生成Vnode，再生成真实dom
        updated
        5.不再使用
        beforUnmount
        将之前挂载再虚拟DOM中VNode从虚拟DOM移除，diff算法发现虚拟dom发生改变，改变真实dom
        unmounted（相对重要 回收操作 1.取消事件监听）
        将组件实例销毁掉


  2.组件中的ref引用 (必须掌握)
    2.1.$refs的使用
      某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例
        .在Vue开发中我们是不推荐进行原生DOM操作的；
        .这个时候，我们可以给元素或者组件绑定一个ref的attribute属性；
      组件实例有一个$refs属性
        .它是一个对象Object，持有注册过ref attribute 的所有元素和组件实例  （只要在template写过ref，所有它对应的元素或者组件都可以放到$refs里面）
        ; 所有可以获取所有元素

    

  3.动态组件的使用
    12案例

  4.keep-alive组件
    4.1.认识keep-alive
    keep-alive属性
      include -String|RegExp|Array 。只有名称匹配的组件会被缓存；
      exclude -String|RegExp|Array 。任何名称匹配的组件都不会被缓存
      max -number|String 最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁
    include和exclude prop允许组件有条件地缓存：  包括的组件不能有逗号，具体看04项目 13app.vue
      二者都可以用逗号分隔字符串，正则表达式或一个数组来表示
      匹配首先检查组件自身name选项 

    4.2缓存组件的生命周期
      对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的
        但是有时候我们确实希望监听到何时进入到组件，何时离开了组件
        这个时候我们可以使用 activated和deactivated这两个生命周期钩子函数来监听


  5.异步组件的使用
    1.Webpack的代码分包
      1.1.默认打包过程
        .默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组件模块打包到一起（比如一个app.js文件）
        .这个时候项目不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢
      1.2打包时，代码的分包
        .所以，对于一些不需要立即使用的组件，我们可以单独对他们进行拆分，拆分成一些小的代码块chunk.js
      1.3那么webpack中如何可以对代码进行分包呢？
        Vue中实现异步组件
        如果我们的项目过大了，对于某些组件我们希望通过异步的方式进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数 defineAsyncComponent

        defineAsyncComponent接收两种类型的参数：
          类型一：工厂函数，该工厂函数需要返回一个promis对象
          类型二：接受一个对象类型，对异步函数进行配置

      vue项目打包后会打包到dist文件夹里，dist文件夹下的js文件夹中chunk-vendors.xxx.js文件存放的是第三方打包的代码如 vue.js框架元源码，
      app.xxx.js文件放的都是自己的的代码
      当我们写了很多页面，且各个页面都有自己的逻辑，这些代码都会放到一起打包的app.xxx.js文件夹当中，这个文件会变得越来越大。
      这就产生了问题：首屏渲染速度

      什么是首屏渲染速度呢？
        假如对整个项目进行部署，就相当于吧打包好的文件放到静态服务器里面（有如：index.html,favicon.ico, css/style.css /,js/app.js js/vendors.js）
        如果文件非常的大，用户在浏览器里面1.先下载html，在下载第三方的包（vendors.js）和自己写的代码的包（app.js）等这两个包下载完成后才能解析里面
        的js代码，解析完用户才能在界面看到渲染的效果。
        但是现在如果我们有三个页面，用户可能同时展示三个页面吗？。用户只会展示其中一个页面，因为这三个页面都打包到同一个app.js里，所以在下载的时候会下载
        全部的js文件，所以这个时候会造成吧所以页面代码都下载下来才开始解析。如果业务多了，用户看到第一个页面的速度是非常的慢的。但是里面有很多页面代码
        是不需要渲染的，所以影响首屏渲染速度。
      怎么样才能不打包到一起呢？
      单独打包math.js
        webpack有对应的打包规则
        1.使用import函数，可以让webpack对导入文件进行分包处理
        import("./utils/math").then(res =>{
          res.sum(20, 30)
        })

  6.组件的v-model
    6.1.前面我们在input中可以使用v-model来完成双向绑定：
      这个时候非常方便，因为v-model默认帮助我们完成了两件事；
      v-bind:value的数据绑定和@input的事件监听
    如果我们封装了一个组件，其他地方在使用这个组件时，是否也可以使用v-model来同时完成这两个功能呢？
      也是可以的，vue也支持在组件上使用v-model；
    当我们在组件上使用的时候，等价于如下操作；
      .我们会发现和input元素不同的只是属性的名称和事件触发的名称而已；
  
  组件v-model的实现
    .为了让组件可以正常工作，这个组件内的<input>必须：
      将其value attribute绑定到一个叫modelValue 的prop上
      在其input事件被触发时，将新的值通过自定义的update：modelValue事件抛出
      在15_组件的v-model里面

    6.2.绑定多个属性
      我们现在通过v-model是直接绑定了一个属性，如果我们希望绑定多个属性呢？
        .也就是我们希望一个组件上使用多个v-model是否可以实现？
        .我们知道，默认情况下的v-model其实是绑定了modelValue属性和@update:modelValue的事件
        .如果我们希望绑定更多，可以给v-model传递一个参数，那么这个参数名称就是我们绑定属性的名称
      在15_组件的 Counter2和app.vue中有具体操作

  7.组件的混入Mixin
  在16_组件的混入
    7.1认识Mixin
      .目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。
      .在vue2和vue3中都支持一种方式就是使用Mixin来完成：
        .Mixin提供了一种非常灵活的方式，来分发vue组件中的可复用功能
        .一个Mixin对象可以包含任何组件选项；
        .当组件使用Mixin对象时。所有Mixin对象的选项被混合进入该组件本身的选项中；
    
    7.2mixin的合并规则
     .如果Mixin对象中的选项和组件中的选项发生了冲突，那么Vue会如何操作呢？
        这里分不同情况来进行处理
        1.情况一：如果是data函数的返回值对象
          1.1返回对象默认情况下会进行合并；
          如果data返回对象的属性发生了冲突，那么会保留组件自身的数据
        2.情况二：如果生命周期钩子函数
          1.2生命周期的钩子函数会合并到到数组中，都会被调用
        3.情况三：值为对象的选项，例如 methods，components，directives，将被合并为同一个对象
          .比如都有methods选项，并且都定义了方法，那么它们都会生效；
          但如果对象的key相同，那么会取组件对象的键值对；

    7.3全局混入Mixin
      .如果组件中的某些选项，是所有组件都需要拥有的，那么这个时候我们就可以使用全局的mixin：
        .全局的Mixin可以使用应用app的方法mixin来完成注册
        .一旦注册，那么全局混入的选项将会影响每一个组件

  内容回顾
  一。非父子组件的通信
    1.1Provide/Inject
      .基本使用
      .函数写法
      .数据的响应式
        .computed
      
      1.2事件总线hy-event-store
      .在event-bus.js中创建eventBus对象
      .监听事件：
        .eventBus.on()
      .发出事件:
        .eventBus.emit()
  二。额外知识补充
    2.1.生命周期函数
      .created
      .mounted
      .unmounted 

    2.2.refs引入元素/组件 
      .在元素/组件中添加ref属性
      .this.$refs属性
    
    2.3.动态组件的使用
    component is 

    2.4.keep-alive属性
      .让组件缓存起来，存活下来
      .include/exclude/max
      .存活组件的生命周期
        .activated
        .deactivated

    2.5.异步组件的使用
      2.5.1.webpack分包处理
        .import()

      2.5.2异步组件
        defineAsyncComponent(() => import(""))

    2.6.v-model组件上
      <counter v-model="appCounter"/>
      相当于下面
      <counter v-bind:modelvalue="appCounter" @update:modelvalue="appCounter = $event"/>
      ; 自定义model
      <counter v-model:counter="appCounter"/>

    2.7.混入Mixin
      .在


        
    


********
********注意（理解）= 非常熟练 （掌握） = 烂熟于心 （重要》掌握） （了解） = 有时间多专研
